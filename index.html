diff --git a/index.html b/index.html
index f438f6f2808f85fa2aba593c6c2182a15e44dac4..d07ba4470119cf24bcf93ff6bb36570f9105b3c5 100644
--- a/index.html
+++ b/index.html
@@ -1923,51 +1923,51 @@ document.addEventListener('DOMContentLoaded', () => {
 		'w-pie-winloss':    '⚖️',
 		'w-pie-bysymbol':   '💲/🌐',
 		'w-capital-profit': '💰',
 		'w-adv-stats':      '📊',
 		'w-eco-cal':        '📅' // seulement si tu affiches un header pour le calendrier
 	  };
 	  Object.entries(ICONS).forEach(([id, icon]) => {
 		const el = document.querySelector(`[data-widget-id="${id}"] .widget-title`);
 		if (el && !el.textContent.trim().startsWith(icon)) {
 		  el.textContent = `${icon} ${el.textContent.trim()}`;
 		}
 	  });
 	})();
 
 	// Désactive les titres intégrés Chart.js (pour éviter la redite)
 	[pie1, pie2, capProfit].forEach(c => {
 	  if (c?.options?.plugins?.title) c.options.plugins.title.display = false;
 	  c?.update?.('none');
 	});
 
   // === STATISTIQUES AVANCÉES
   function stddev(arr) { if (!arr || arr.length < 2) return NaN; const m = arr.reduce((a,b)=>a+b,0)/arr.length; const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0)/(arr.length-1); return Math.sqrt(v); }
   function maxDrawdown(series) { if (!series || series.length===0) return 0; let peak=series[0].equity, maxDD=0; for (const p of series){ peak=Math.max(peak,p.equity); maxDD=Math.max(maxDD, peak-p.equity);} return maxDD; }
   function streaks(arr){ let wc=0,lc=0,wmax=0,lmax=0; for (const v of arr){ if(v>0){wc++;lc=0;wmax=Math.max(wmax,wc);} else if(v<0){lc++;wc=0;lmax=Math.max(lmax,lc);} else {wc=0;lc=0;} } return {wmax,lmax}; }
   function computeAdvancedStats() {
-    const trades = state.realizedEvents.map(e => e.pnl);
+    const trades = state.realizedEvents.filter(e => e && e.symbol).map(e => e.pnl);
     const n = trades.length;
     const total = state.realizedPL;
     const wins = trades.filter(v => v > 0);
     const losses = trades.filter(v => v < 0);
     const nW = wins.length, nL = losses.length;
     const avg = n ? total / n : NaN;
     const sumW = wins.reduce((a,b)=>a+b,0);
     const sumLAbs = Math.abs(losses.reduce((a,b)=>a+b,0) || 0);
     const avgW = nW ? sumW / nW : NaN;
     const avgL = nL ? (losses.reduce((a,b)=>a+b,0) / nL) : NaN;
     const pf = sumLAbs > 0 ? (sumW / sumLAbs) : (sumW > 0 ? Infinity : 0);
     const gl = (avgW > 0 && avgL < 0) ? (avgW / Math.abs(avgL)) : (avgW > 0 && !nL ? Infinity : (!nW && avgL < 0 ? 0 : NaN));
     const wr = n ? (nW / n * 100) : NaN;
     const sd = stddev(trades);
     const sdDown = stddev(losses);
     const exp = n ? (wr / 100) * (isNaN(avgW) ? 0 : avgW) + ((1 - wr / 100) * (isNaN(avgL) ? 0 : avgL)) : NaN;
     const dd = maxDrawdown(state.equitySeries);
     const rec = dd > 0 ? (total / dd) : NaN;
     const sh = (sd > 0) ? (avg / sd) : NaN;
     const so = (sdDown > 0) ? (avg / sdDown) : NaN;
     const {wmax, lmax} = streaks(trades);
     let cagr = NaN;
     if (state.initialBalance > 0 && state.equitySeries.length > 1) {
       const startT = state.equitySeries[0].t;
       const endT = state.equitySeries[state.equitySeries.length - 1].t;
diff --git a/index.html b/index.html
index f438f6f2808f85fa2aba593c6c2182a15e44dac4..d07ba4470119cf24bcf93ff6bb36570f9105b3c5 100644
--- a/index.html
+++ b/index.html
@@ -2002,51 +2002,53 @@ document.addEventListener('DOMContentLoaded', () => {
       <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
         <div><strong>Total Profit :</strong> ${fmt2(s.total)}</div>
         <div><strong>Recovery Factor :</strong> ${fmt2(s.rec, 2)}</div>
         <div><strong>Total Trades :</strong> ${fmt2(s.n, 0)}</div>
         <div><strong>Expectancy :</strong> ${fmt2(s.exp, 2)}</div>
         <div><strong>Winning Trades :</strong> ${fmt2(s.nW, 0)}</div>
         <div><strong>Volatilité (Std Dev) :</strong> ${fmt2(s.sd, 2)}</div>
         <div><strong>Losing Trades :</strong> ${fmt2(s.nL, 0)}</div>
         <div><strong>Maximum Drawdown :</strong> ${fmt2(s.dd, 2)}</div>
         <div><strong>Win Rate (%) :</strong> ${fmt2(s.wr, 2)}</div>
         <div><strong>Max Winning Streak :</strong> ${fmt2(s.wmax, 0)}</div>
         <div><strong>Average Profit :</strong> ${fmt2(s.avg, 2)}</div>
         <div><strong>Max Losing Streak :</strong> ${fmt2(s.lmax, 0)}</div>
         <div><strong>Average Winning Profit :</strong> ${fmt2(s.avgW, 2)}</div>
         <div><strong>Sharpe Ratio :</strong> ${fmt2(s.sh, 2)}</div>
         <div><strong>Average Losing Profit :</strong> ${fmt2(s.avgL, 2)}</div>
         <div><strong>Sortino Ratio :</strong> ${fmt2(s.so, 2)}</div>
         <div><strong>Gain/Loss Ratio :</strong> ${fmt2(s.gl, 2)}</div>
         <div><strong>Profit Factor :</strong> ${fmt2(s.pf, 2)}</div>
         <div><strong>CAGR :</strong> ${Number.isNaN(s.cagr) ? 'N/A' : (fmt2(100 * s.cagr, 2) + ' %')}</div>
       </div>`;
   }
   function recomputeKpisForSim() {
     if (!isSimAccountName(selectedAccount)) return;
     const day0 = new Date(); day0.setHours(0, 0, 0, 0);
-    const daily = state.realizedEvents.filter(e => e.t >= day0.getTime()).reduce((a, e) => a + (e.pnl || 0), 0);
+    const daily = state.realizedEvents
+      .filter(e => e.t >= day0.getTime())
+      .reduce((a, e) => a + (e.delta ?? e.pnl ?? 0), 0);
     const lastCashForThis = (state.lastCashBalanceAccount === selectedAccount) ? state.lastCashBalance : null;
     const base = (Number.isFinite(lastCashForThis) && lastCashForThis !== 0)
       ? lastCashForThis
       : (Math.max(0, state.initialBalance ?? 0) + state.realizedPL);
     qs('#kpiBalance').textContent = fmt(base, 2);
     qs('#kpiAvailable').textContent = fmt(base, 2);
     qs('#kpiDailyPL').textContent = fmt(daily, 2);
   }
   function refreshCharts() {
     pie1.data.datasets[0].data = [state.wins, state.losses];
     pie1.update('none');
     const entries = [...state.symbolPL.entries()].sort((a,b)=>Math.abs(b[1]) - Math.abs(a[1])).slice(0,6);
     pie2.data.labels = entries.map(e=>e[0]);
     pie2.data.datasets[0].data = entries.map(e=>Math.abs(e[1]));
     pie2.data.datasets[0].backgroundColor = entries.map(e=>colorForSymbol(e[0]));
     pie2.update('none');
 	//equity.data.labels = []; // plus utilisé
 	equity.data.datasets[0].data = state.equitySeries.map(e => ({
 	  x: e.t,                                  // timestamp en ms
 	  y: Number(e.equity.toFixed(2))
 	}));
     const tradeDataArray = [], pointBackgroundColors = [], pointBorderColors = [];
     for (let i = 0; i < state.equitySeries.length; i++) {
       const equityPoint = state.equitySeries[i];
       const tradeEvent = state.realizedEvents[i];
diff --git a/index.html b/index.html
index f438f6f2808f85fa2aba593c6c2182a15e44dac4..d07ba4470119cf24bcf93ff6bb36570f9105b3c5 100644
--- a/index.html
+++ b/index.html
@@ -2193,83 +2195,136 @@ document.addEventListener('DOMContentLoaded', () => {
 		return `${symbol}|${side}|${qty}|t${ticksRounded}|s${secBucket}`;
 	}
 
 	// Traite un "fill" (live 301 ou historique 304) avec dédup tolérante
 	// exactKey permet d'utiliser un ID d'exécution serveur si disponible (idéal)
 	function applyFill(symbol, side, qty, price, ts, commission = 0, exactKey = null) {
 		if (!symbol || !side || !qty || !Number.isFinite(price) || !Number.isFinite(ts)) return;
 
 		const key = exactKey || approxFillKey(symbol, side, qty, price, ts);
 		if (seenFillKeys.has(key)) return; // déjà vu (exact ou approx)
 		seenFillKeys.add(key);
 
 		// On garde aussi une “seconde chance” avec une clé approx systématique,
 		// utile si on a eu une exactKey une fois et pas la fois suivante.
 		seenFillKeys.add(approxFillKey(symbol, side, qty, price, ts));
 
 		lastProcessedFillMS = Math.max(lastProcessedFillMS, ts);
 
 		// Met à jour position interne + agrégation FIFO → trades réalisés
 		updatePositionAndRealized(symbol, price, side * qty);
 
 		// Si le fill est une fermeture d'un swing antérieur non vu dans l'historique chargé,
 		// injecte un "lot hérité" au début de la fenêtre pour permettre une agrégation correcte.
 		try { ensureSeedForClose(symbol, side, qty); } catch (e) { /* silencieux */ }
 
-		let trades = aggregateFromFill(symbol, side, qty, price, ts);
-		if (Number.isFinite(commission) && commission !== 0 && trades.length) {
-			const totQty = trades.reduce((a, t) => a + t.qty, 0) || 1;
-			trades = trades.map(t => ({ ...t, pnl: t.pnl - commission * (t.qty / totQty) }));
-		}
-
-		for (const t of trades) {
-			const inRange = shouldIncludeTrade(t.closeTime);
-
-			if (inRange) {
-				state.realizedPL += t.pnl;
-
-				if (!state.symbolPL.has(t.symbol)) state.symbolPL.set(t.symbol, 0);
-				state.symbolPL.set(t.symbol, state.symbolPL.get(t.symbol) + t.pnl);
-
-				if (t.pnl > 0) state.wins++; else if (t.pnl < 0) state.losses++;
-
-				state.equitySeries.push({ t: t.closeTime, equity: state.realizedPL });
-				state.realizedEvents.push({
-					pnl: t.pnl, t: t.closeTime, symbol: t.symbol, side: t.side, qty: t.qty,
-					entry: t.entry, exit: t.exit, openTime: t.openTime, closeTime: t.closeTime
-				});
-
-				addTradeRowTrade(t);
-			}
-		}
-
-		if (trades.length) {
-			const em = document.getElementById('emptyMsg'); if (em) em.style.display = 'none';
-			refreshCharts();
-			recomputeKpisForSim();
-			requestKpisNow();
-		}
+                const aggregation = aggregateFromFill(symbol, side, qty, price, ts);
+                const partials = aggregation.partials || [];
+                let trades = aggregation.trades || [];
+
+                for (const part of partials) {
+                        if (!shouldIncludeTrade(part.closeTime)) continue;
+
+                        state.realizedPL += part.pnl;
+
+                        if (!state.symbolPL.has(part.symbol)) state.symbolPL.set(part.symbol, 0);
+                        state.symbolPL.set(part.symbol, state.symbolPL.get(part.symbol) + part.pnl);
+
+                        if (part.lotRef) {
+                                part.lotRef.countedPnl = (part.lotRef.countedPnl || 0) + part.pnl;
+                        }
+
+                        const { lotRef, ...eventPart } = part;
+
+                        state.equitySeries.push({ t: eventPart.closeTime, equity: state.realizedPL });
+                        state.realizedEvents.push({
+                                pnl: eventPart.pnl,
+                                delta: eventPart.pnl,
+                                t: eventPart.closeTime,
+                                symbol: null,
+                                side: eventPart.side,
+                                qty: eventPart.qty,
+                                entry: null,
+                                exit: null,
+                                openTime: eventPart.openTime,
+                                closeTime: eventPart.closeTime,
+                                synthetic: true
+                        });
+                }
+
+                for (const t of trades) {
+                        if (t && t.lotRef) {
+                                t.countedPnl = Number.isFinite(t.lotRef.countedPnl) ? t.lotRef.countedPnl : 0;
+                                delete t.lotRef;
+                        }
+                }
+
+                if (Number.isFinite(commission) && commission !== 0 && trades.length) {
+                        const totQty = trades.reduce((a, t) => a + t.qty, 0) || 1;
+                        trades = trades.map(t => ({
+                                ...t,
+                                pnl: t.pnl - commission * (t.qty / totQty)
+                        }));
+                }
+
+                for (const t of trades) {
+                        const inRange = shouldIncludeTrade(t.closeTime);
+
+                        if (inRange) {
+                                const delta = t.pnl - (t.countedPnl || 0);
+                                state.realizedPL += delta;
+
+                                if (!state.symbolPL.has(t.symbol)) state.symbolPL.set(t.symbol, 0);
+                                state.symbolPL.set(t.symbol, state.symbolPL.get(t.symbol) + delta);
+
+                                if (t.pnl > 0) state.wins++; else if (t.pnl < 0) state.losses++;
+
+                                state.equitySeries.push({ t: t.closeTime, equity: state.realizedPL });
+                                state.realizedEvents.push({
+                                        pnl: t.pnl,
+                                        delta,
+                                        t: t.closeTime,
+                                        symbol: t.symbol,
+                                        side: t.side,
+                                        qty: t.qty,
+                                        entry: t.entry,
+                                        exit: t.exit,
+                                        openTime: t.openTime,
+                                        closeTime: t.closeTime,
+                                        synthetic: false
+                                });
+
+                                addTradeRowTrade(t);
+                        }
+                }
+
+                if (partials.length || trades.length) {
+                        const em = document.getElementById('emptyMsg'); if (em) em.style.display = 'none';
+                        refreshCharts();
+                        recomputeKpisForSim();
+                        requestKpisNow();
+                }
 	}
 
   // Filet de sécurité : re-demande des fills récents via 303 → 304
 	function requestRecentFills() {
 		if (!client || !state.connected || !selectedAccount) return;
 		if (isLoadingHistory || currentHistoryReqId !== null) return; // évite chevauchement
 
 		const endSec = Math.floor(Date.now() / 1000);
 
 		// 👉 IMPORTANT : on repart LÉGÈREMENT AVANT le dernier fill traité,
 		// pas après. La dédup’ gère les doublons.
 		const startMs = lastProcessedFillMS
 			? Math.max(0, lastProcessedFillMS - SAFETY_LAG_MS)   // ← avant au lieu de après
 			: (Date.now() - 15 * 60 * 1000);
 		const startSec = Math.max(0, Math.floor(startMs / 1000));
 
 		// Rien à demander ? Blink visuel pour montrer un cycle de refresh
 		if (startSec >= endSec) {
 			setRefreshIndicator('active');
 			setTimeout(() => setRefreshIndicator('done'), 150);
 			return;
 		}
 
 		const reqId = Math.floor(Math.random() * 1e6);
 		currentHistoryReqId = reqId;            // on continue d’utiliser la pipeline existante
diff --git a/index.html b/index.html
index f438f6f2808f85fa2aba593c6c2182a15e44dac4..d07ba4470119cf24bcf93ff6bb36570f9105b3c5 100644
--- a/index.html
+++ b/index.html
@@ -2283,71 +2338,98 @@ document.addEventListener('DOMContentLoaded', () => {
 			StartDateTime: startSec,
 			EndDateTime: endSec
 		});
 		// NOTE : on NE met PAS isLoadingHistory=true ici pour laisser passer les 301 live.
 	}
 
 	function startFillsPolling() {
 		if (fillsPollTimer) clearInterval(fillsPollTimer);
 		// 1er tick aléatoire entre 0.5s et 2s, ensuite toutes les 10s
 		const first = Math.random() * 1500 + 500;
 		setTimeout(() => {
 			requestRecentFills();
 			fillsPollTimer = setInterval(requestRecentFills, 10000);
 		}, first);
 	}
 
   function stopFillsPolling() {
     if (fillsPollTimer) { clearInterval(fillsPollTimer); fillsPollTimer = null; }
   }
 
   // === AGRÉGATEUR FIFO Open→Close
   const _openLots = new Map();
   const getLots = (sym) => { if (!_openLots.has(sym)) _openLots.set(sym, []); return _openLots.get(sym); };
   function aggregateFromFill(symbol, side, qty, rawPrice, timeMs) {
     const trades = [];
-    if (!symbol || !side || !qty || !Number.isFinite(rawPrice)) return trades;
+    const partials = [];
+    if (!symbol || !side || !qty || !Number.isFinite(rawPrice)) return { trades, partials };
     const priceN = normalizePrice(symbol, rawPrice);
     const lots = getLots(symbol);
     let remaining = qty;
 
+    const finalizeLot = (lot) => {
+      const parts = Array.isArray(lot.partials) ? lot.partials : [];
+      const totalQty = parts.reduce((sum, p) => sum + (p.qty || 0), 0);
+      if (totalQty <= 0) return null;
+      const totalPnl = parts.reduce((sum, p) => sum + (p.pnl || 0), 0);
+      const weightedExit = parts.reduce((sum, p) => sum + (p.exitPriceN || 0) * (p.qty || 0), 0) / totalQty;
+      const closeTime = parts.reduce((latest, p) => Math.max(latest, p.closeTime || lot.time), lot.time);
+      return {
+        symbol,
+        side: lot.side,
+        qty: totalQty,
+        openTime: lot.time,
+        closeTime,
+        entry: lot.priceN,
+        exit: weightedExit,
+        pnl: totalPnl,
+        countedPnl: lot.countedPnl || 0,
+        lotRef: lot
+      };
+    };
+
     while (remaining > 0 && lots.length && lots[0].side !== side) {
       const lot = lots[0];
+      if (!Array.isArray(lot.partials)) lot.partials = [];
+      if (!Number.isFinite(lot.realizedPnl)) lot.realizedPnl = 0;
+      if (!Number.isFinite(lot.countedPnl)) lot.countedPnl = 0;
       const closed = Math.min(remaining, lot.qty);
       const pnlPoints = (priceN - lot.priceN) * lot.side * closed;
       const pnlCur = priceToCurrency(symbol, pnlPoints);
-      trades.push({
-        symbol, side: lot.side, qty: closed,
-        openTime: lot.time, closeTime: timeMs,
-        entry: lot.priceN, exit: priceN, pnl: pnlCur
-      });
+      lot.partials.push({ qty: closed, exitPriceN: priceN, closeTime: timeMs, pnl: pnlCur });
+      lot.realizedPnl += pnlCur;
+      partials.push({ symbol, side: lot.side, qty: closed, pnl: pnlCur, closeTime: timeMs, openTime: lot.time, lotRef: lot });
       lot.qty -= closed;
       remaining -= closed;
-      if (lot.qty <= 0) lots.shift();
+      if (lot.qty <= 0) {
+        lots.shift();
+        const aggregated = finalizeLot(lot);
+        if (aggregated) trades.push(aggregated);
+      }
     }
-    if (remaining > 0) lots.push({ side, qty: remaining, priceN, time: timeMs });
-    return trades;
+    if (remaining > 0) lots.push({ side, qty: remaining, priceN, time: timeMs, partials: [], realizedPnl: 0, countedPnl: 0 });
+    return { trades, partials };
   }
   function addTradeRowTrade(tr) {
     const trEl = document.createElement('tr');
     const day = new Date(tr.openTime).toLocaleDateString('fr-FR');
     const row = [
       day,
       new Date(tr.openTime).toLocaleString('fr-FR'),
       new Date(tr.closeTime).toLocaleString('fr-FR'),
       tr.symbol||'—',
       sideLabelFrom(tr.side),
       String(tr.qty),
       fmt(tr.entry,2),
       fmt(tr.exit,2),
       fmt(tr.pnl,2)
     ];
     for (const txt of row) { const td = document.createElement('td'); td.textContent = txt; trEl.appendChild(td); }
     const pnlCell = trEl.lastElementChild;
     if (tr.pnl > 0) pnlCell.style.color = getVar('--green') || '#22c55e';
     else if (tr.pnl < 0) pnlCell.style.color = getVar('--red') || '#ef4444';
     qs('#tradesTable tbody').prepend(trEl);
   }
 	// --- Helpers Positions → par symbole (somme nette + moyenne pondérée)
 	function getOpenPosForSymbol(symbol) {
 		if (!symbol) return null;
 		let net = 0, wSum = 0, qSum = 0;
diff --git a/index.html b/index.html
index f438f6f2808f85fa2aba593c6c2182a15e44dac4..d07ba4470119cf24bcf93ff6bb36570f9105b3c5 100644
--- a/index.html
+++ b/index.html
@@ -2375,59 +2457,62 @@ document.addEventListener('DOMContentLoaded', () => {
 	// créé UNIQUEMENT quand un fill in-range tente de fermer une position
 	// ouverte avant la fenêtre (swing multi-jours/mois) que l'historique chargé
 	// ne permet pas de reconstruire. On s'appuie sur 305/306 (snapshot courant).
 	//
 	// Sécurité : on NE sème pas si le snapshot est vide ou si le fill n'est
 	// pas en fermeture (ex: SELL alors que position nette ≤ 0).
 		
 	function ensureSeedForClose(symbol, incomingSide, incomingQty) {
 		if (!symbol || !incomingSide || !incomingQty) return;
 		if (FILTER_FROM_MS == null) return;
 
 		const lots = getLots(symbol);
 
 		// Assez d'opposé déjà présent ? (ouverture vue dans le contexte) → rien à faire
 		const needed = Math.max(0, incomingQty - oppositeQtyAvailable(lots, incomingSide));
 		if (needed <= 0) return;
 
 		// Snapshot courant des positions : sert d'indice pour savoir s'il s'agit d'une fermeture
 		const pos = getOpenPosForSymbol(symbol);
 		if (!pos) return; // pas d'info exploitable → on ne sème pas (évite faux positifs)
 
 		// Si le signe de la position est opposé au side du fill => c'est une FERMETURE
 		// (ex: position long >0, fill SELL => incomingSide=-1 → pos.qty * incomingSide < 0)
 		if (pos.qty * incomingSide < 0) {
 			// Sème juste ce qu'il faut pour permettre la fermeture
-			lots.unshift({
-				side: -incomingSide,
-				qty: needed,
-				priceN: pos.avg,                // moyen courant (meilleure approximation dispo sans remonter +)
-				time: FILTER_FROM_MS - 1,       // horodatage juste avant la fenêtre
-				inherited: true
-			});
-		}
-	}
+                        lots.unshift({
+                                side: -incomingSide,
+                                qty: needed,
+                                priceN: pos.avg,                // moyen courant (meilleure approximation dispo sans remonter +)
+                                time: FILTER_FROM_MS - 1,       // horodatage juste avant la fenêtre
+                                inherited: true,
+                                partials: [],
+                                realizedPnl: 0,
+                                countedPnl: 0
+                        });
+                }
+        }
 
   // === SÉLECTION COMPTE
   function pickAccount(acc) {
     selectedAccount = acc;
     localStorage.setItem('selectedAccount', selectedAccount);
     const sel = qs('#accountSelect'); if (sel) sel.value = selectedAccount;
     if (!initialDataSent) requestInitialData(selectedAccount);
   }
   function fallbackSelectAccount() {
     if (selectedAccount) return;
     const ls = localStorage.getItem('selectedAccount');
     const lsMatch = [...accounts].find(a => a === ls);
     if (lsMatch) return pickAccount(lsMatch);
     if (accounts.size === 1 && !accountPreference) return pickAccount([...accounts][0]);
   }
   function trySelectPreferredAccount() {
     if (selectedAccount) return;
     const typed = (accountPreference || '').trim();
     if (typed) {
       const match = [...accounts].find(a => a.toLowerCase() === typed.toLowerCase());
       if (match) { pickAccount(match); if (accountPreferenceTimer) { clearTimeout(accountPreferenceTimer); accountPreferenceTimer = null; } return; }
       if (!accountPreferenceTimer) {
         accountPreferenceTimer = setTimeout(() => { if (!selectedAccount) fallbackSelectAccount(); }, 2000);
       }
       return;
diff --git a/index.html b/index.html
index f438f6f2808f85fa2aba593c6c2182a15e44dac4..d07ba4470119cf24bcf93ff6bb36570f9105b3c5 100644
--- a/index.html
+++ b/index.html
@@ -2797,51 +2882,52 @@ document.addEventListener('DOMContentLoaded', () => {
   function processHistoricalFills() {
     try {
       // tri par DateTime croissant
       _fillsBuffer.sort((a,b)=> safeNumber(a.DateTime) - safeNumber(b.DateTime));
 
       const maxFills = Math.max(1, safeNumber(qs('#maxFills').value) || 500);
       const buffer = _fillsBuffer.length > maxFills
         ? _fillsBuffer.slice(_fillsBuffer.length - maxFills)
         : _fillsBuffer;
 
       let tradesCount = 0;
 
       for (const f of buffer) {
 		checkClockDrift(safeNumber(f.DateTime));
         const symbol = safeString(f.Symbol) || '—';
         const price  = safeNumber(f.Price);
         const qty    = safeNumber(f.Quantity);
         const side   = sideFrom(f.BuySell);
         const ts     = parseDtcTime(f.DateTime);
         if (!side || !qty || !price) continue;
 
         const comm = safeNumber(f.Commission ?? 0);
         // Utilise la même pipeline que le live (dédup incluse)
         const beforeEvents = state.realizedEvents.length;
         applyFill(symbol, side, qty, price, ts, comm);
-        tradesCount += Math.max(0, state.realizedEvents.length - beforeEvents);
+        const newEvents = state.realizedEvents.slice(beforeEvents);
+        tradesCount += newEvents.filter(ev => ev && ev.symbol).length;
 
         state.fills.push(f);
       }
 
       _fillsBuffer.length = 0;
 
       qs('#statusPill').textContent = 'Historique chargé';
       currentHistoryReqId = null;
       isLoadingHistory = false;
 
       const em = qs('#emptyMsg');
       if (em) em.style.display = tradesCount ? 'none' : 'block';
 
       showStatusMessage(`${tradesCount} trades chargés`, 'success', 3000);
 
       // Après l'historique, on force un KPI refresh + polling sécurisé
       recomputeKpisForSim();
       refreshCharts();
       requestKpisNow();
 
     } catch (error) {
       console.error('Erreur lors du traitement de l\'historique:', error);
       showStatusMessage('Erreur lors du traitement de l\'historique', 'error');
       isLoadingHistory = false;
     }
